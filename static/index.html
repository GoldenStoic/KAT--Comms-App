<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Voice+Chat Room</title>
  <style>
    body { font-family: sans-serif; }
    #waiting, #chat, #controls, #material { margin: 1em; }
  </style>
</head>
<body>
  <h1>Training Room</h1>

  <div id="waiting">Waiting for admin to admit‚Ä¶</div>

  <div id="controls" style="display:none;">
    <button id="admitBtn">(Admin) Admit Selected</button>
    <select id="waitingList"></select>
    <br/><br/>
    <button id="nextSlide">Next Slide</button>
    <button id="startQuiz">Start Quiz</button>
  </div>

  <div id="material"></div>

  <div id="chat" style="display:none;">
    <div id="chatLog" style="height:200px; overflow:auto; border:1px solid #ccc;"></div>
    <input id="msgIn" placeholder="Message‚Ä¶"/><button id="sendBtn">Send</button>
  </div>

  <script>
    const token   = prompt("Enter token (admin or user JWT)");
    const roomId  = "room123";
    const proto   = location.protocol === "https:" ? "wss" : "ws";
    const ws      = new WebSocket(`${proto}://${location.host}/ws/${roomId}?token=${encodeURIComponent(token)}`);

    let ICE_SERVERS = [];
    let pc, localStream, hasOffered = false;

    // Fetch ICE servers from our Python /ice endpoint
    async function loadIceServers() {
      console.log("üîç Fetching ICE servers from /ice");
      const res = await fetch("/ice");
      ICE_SERVERS = await res.json();
      console.log("‚úÖ ICE_SERVERS loaded:", ICE_SERVERS);
    }

    ws.onopen = () => console.log("üîó WebSocket connected");
    ws.onclose= () => console.log("üîå WebSocket closed");

    ws.onmessage = async ({ data }) => {
      console.log("üì© raw ws msg:", data);
      let msg;
      try { msg = JSON.parse(data); }
      catch { console.error("‚ùå Invalid WS JSON:", data); return; }

      switch (msg.type) {
        case "waiting":
          console.log("‚è≥ Received 'waiting'");
          document.getElementById("waiting").style.display = "block";
          break;

        case "new_waiting":
          console.log("üë• Received 'new_waiting'", msg.peer_id);
          const sel = document.getElementById("waitingList");
          const opt = document.createElement("option");
          opt.value = msg.peer_id;
          opt.text  = `User ${msg.peer_id}`;
          sel.appendChild(opt);
          break;

        case "admitted":
          console.log("‚úÖ Admitted ‚Äî UI unlocked, peer_id:", msg.peer_id);
          document.getElementById("waiting").style.display  = "none";
          document.getElementById("chat").style.display     = "block";
          document.getElementById("controls").style.display =
            (tokenRole() === "admin") ? "block" : "none";
          break;

        case "ready_for_offer":
          console.log("üì® ready_for_offer received");
          document.getElementById("waiting").style.display  = "none";
          document.getElementById("chat").style.display     = "block";
          document.getElementById("controls").style.display =
            (tokenRole() === "admin") ? "block" : "none";
          if (!hasOffered) {
            hasOffered = true;
            await loadIceServers();
            await startWebRTC();
          }
          break;

        case "answer":
          console.log("üîÑ Received answer ‚Äî signalingState before:", pc.signalingState);
          if (pc && pc.signalingState === "have-local-offer") {
            try {
              await pc.setRemoteDescription(
                new RTCSessionDescription({ type:"answer", sdp:msg.sdp })
              );
              console.log("‚úîÔ∏è setRemoteDescription succeeded ‚Äî state now:", pc.signalingState);
            } catch(e) {
              console.error("‚ùå setRemoteDescription error:", e);
            }
          } else {
            console.warn("‚ùå Skipping setRemoteDescription in wrong state:", pc ? pc.signalingState : "no-pc");
          }
          break;

        case "ice":
          console.log("üíß Received ICE candidate from server:", msg.candidate);
          if (pc && msg.candidate) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
              console.log("‚úîÔ∏è addIceCandidate succeeded");
            } catch(e) {
              console.warn("‚ö†Ô∏è addIceCandidate failed:", e);
            }
          }
          break;

        case "chat":
          console.log("üí¨ Received chat from", msg.from, ":", msg.text);
          document.getElementById("chat").style.display = "block";
          const log = document.getElementById("chatLog");
          log.innerHTML += `<div><b>${msg.from}:</b> ${msg.text}</div>`;
          log.scrollTop = log.scrollHeight;
          break;

        case "material_event":
          console.log("üìö Received material_event:", msg.event, msg.payload);
          handleMaterial(msg.event, msg.payload);
          break;

        default:
          console.warn("‚ùì Unknown message type:", msg.type);
      }
    };

    async function startWebRTC() {
      console.log("üõ´ startWebRTC()");
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log("üé§ getUserMedia succeeded");
      } catch (err) {
        console.error("‚ùå getUserMedia failed:", err);
        alert("Microphone access is required: " + err.message);
        return;
      }

      pc = new RTCPeerConnection({
        iceServers: ICE_SERVERS,
        iceTransportPolicy: "relay"  // optional: force TURN-only
      });
      console.log("üîß RTCPeerConnection created, signalingState:", pc.signalingState);

      pc.ontrack = e => {
        console.log("üîä Remote track received");
        const audio = document.createElement("audio");
        audio.srcObject = e.streams[0];
        audio.autoplay = true;
        document.body.appendChild(audio);
      };

      pc.onicecandidate = e => {
        if (e.candidate) {
          console.log("üíß Local ICE candidate:", e.candidate);
          ws.send(JSON.stringify({ type:"ice", candidate:e.candidate.toJSON() }));
        }
      };

      // Add local audio tracks
      localStream.getTracks().forEach(t => {
        pc.addTrack(t, localStream);
        console.log("‚ûï Added local track:", t.kind);
      });
      console.log("üé¨ Tracks added, signalingState:", pc.signalingState);

      // Use negotiationneeded to guarantee correct timing
      pc.onnegotiationneeded = async () => {
        console.log("üîÑ negotiationneeded event ‚Äî preparing offer");
        try {
          const offer = await pc.createOffer();
          console.log("‚úàÔ∏è Offer created");
          await pc.setLocalDescription(offer);
          console.log("‚úàÔ∏è setLocalDescription done ‚Äî signalingState:", pc.signalingState);

          // Wait for ICE gathering to finish
          await new Promise(resolve => {
            if (pc.iceGatheringState === "complete") return resolve();
            function check() {
              console.log("üïì ICE gathering state:", pc.iceGatheringState);
              if (pc.iceGatheringState === "complete") {
                pc.removeEventListener("icegatheringstatechange", check);
                resolve();
              }
            }
            pc.addEventListener("icegatheringstatechange", check);
          });

          console.log("üéâ ICE gathering complete ‚Äî sending SDP");
          ws.send(JSON.stringify({ type:"offer", sdp:pc.localDescription.sdp }));
          console.log("‚úâÔ∏è Offer sent to server");
        } catch(e) {
          console.error("‚ùå Error during negotiationneeded:", e);
        }
      };
    }

    // UI event handlers
    document.getElementById("sendBtn").onclick = () => {
      const txt = document.getElementById("msgIn").value;
      console.log("üì§ Sending chat:", txt);
      ws.send(JSON.stringify({ type:"chat", from:tokenRole(), text:txt }));
      document.getElementById("msgIn").value = "";
    };
    document.getElementById("admitBtn").onclick = () => {
      const peerId = Number(document.getElementById("waitingList").value);
      console.log("‚úÖ Admin admitting peer_id:", peerId);
      ws.send(JSON.stringify({ type:"admit", peer_id:peerId }));
    };
    document.getElementById("nextSlide").onclick = () => {
      console.log("‚û°Ô∏è Sending next_slide event");
      ws.send(JSON.stringify({ type:"material_event", event:"next_slide" }));
    };
    document.getElementById("startQuiz").onclick = () => {
      console.log("‚ùì Sending start_quiz event");
      ws.send(JSON.stringify({
        type:"material_event", event:"start_quiz", payload:{ quizId:42 }
      }));
    };

    function tokenRole() {
      try {
        const role = JSON.parse(atob(token.split(".")[1])).role;
        console.log("üîë tokenRole:", role);
        return role;
      } catch {
        console.warn("‚ö†Ô∏è Unable to parse tokenRole, defaulting to user");
        return "user";
      }
    }

    function handleMaterial(event, payload) {
      const mat = document.getElementById("material");
      if (event === "next_slide") {
        mat.innerHTML += "<p>‚û°Ô∏è Next slide</p>";
      }
      if (event === "start_quiz") {
        mat.innerHTML += `<p>‚ùì Quiz ${payload.quizId}</p>`;
      }
    }
  </script>
</body>
</html>
