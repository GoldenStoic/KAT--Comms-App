<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Audio Room</title>
</head>
<body>
  <h1>Audio Room</h1>
  <p>
    <button id="start">Join Room</button>
    <button id="admit" disabled>Admit Waiting User</button>
  </p>
  <div>
    <input id="chatInput" placeholder="Type a messageâ€¦">
    <button id="sendChat">Send</button>
  </div>
  <ul id="messages"></ul>

<script>
  const log = console.log;
  let ws, pc, myRole, myId, pendingId;

  document.getElementById('start').onclick = joinRoom;
  document.getElementById('admit').onclick = () => {
    ws.send(JSON.stringify({type:'admit', peer_id: pendingId}));
    document.getElementById('admit').disabled = true;
  };
  document.getElementById('sendChat').onclick = () => {
    const txt = document.getElementById('chatInput').value;
    ws.send(JSON.stringify({type:'chat', from:myRole, text:txt}));
    document.getElementById('chatInput').value = '';
  };

  async function joinRoom() {
    // choose role by URL:  add ?admin to become admin
    myRole = location.search.includes('admin') ? 'admin' : 'user';
    const token = ''; // put your JWT here if youâ€™re using auth
    ws = new WebSocket(`ws://${location.host}/ws/room1?token=${token}`);

    ws.onopen = () => log('ðŸ”— WebSocket open');
    ws.onmessage = async e => {
      const msg = JSON.parse(e.data);
      log('ðŸ“©', msg);
      switch(msg.type) {
        case 'waiting':
          log('â³ Waiting for admin to admit');
          document.getElementById('start').disabled = true;
          break;

        case 'new_waiting':
          pendingId = msg.peer_id;
          document.getElementById('admit').disabled = (myRole!=='admin');
          break;

        case 'admitted':
          myId = msg.peer_id;
          log('âœ… Admitted, peer_id =', myId);
          document.getElementById('start').disabled = true;
          break;

        case 'ready_for_offer':
          await setupWebRTC();
          break;

        case 'ice':
          await pc.addIceCandidate(msg.candidate);
          break;

        case 'answer':
          await pc.setRemoteDescription({type:'answer', sdp:msg.sdp});
          log('âœ”ï¸ Remote description set');
          break;

        case 'chat':
          const li = document.createElement('li');
          li.textContent = msg.from + ': ' + msg.text;
          document.getElementById('messages').append(li);
          break;
      }
    };
  }

  async function setupWebRTC() {
    // fetch TURN/STUN
    const iceServers = await (await fetch('/ice')).json();

    // only TURN candidates (relay) pass to the server
    pc = new RTCPeerConnection({
      iceTransportPolicy: 'relay',
      iceServers,
    });

    pc.onicecandidate = ({candidate}) => {
      if (candidate) {
        ws.send(JSON.stringify({type:'ice', candidate}));
      }
    };

    pc.ontrack = ({track}) => {
      if (track.kind === 'audio') {
        const audio = new Audio();
        audio.srcObject = new MediaStream([track]);
        audio.play();
      }
    };

    pc.onnegotiationneeded = async () => {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({type:'offer', sdp: pc.localDescription.sdp}));
    };

    // grab mic & send to server
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    stream.getTracks().forEach(t => pc.addTrack(t, stream));
  }
</script>
</body>
</html>
