<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Voice+Chat Room (Debug Mode)</title>
  <style>
    body { font-family: sans-serif; }
    #waiting, #chat, #controls, #material { margin: 1em; }
    #stats { font-family: monospace; white-space: pre; background: #f0f0f0; padding: 1em; }
  </style>
</head>
<body>
  <h1>Training Room (Debug Mode)</h1>

  <div id="waiting">Waiting for admin to admit‚Ä¶</div>

  <div id="controls" style="display:none;">
    <button id="admitBtn">(Admin) Admit Selected</button>
    <select id="waitingList"></select>
    <br/><br/>
    <button id="nextSlide">Next Slide</button>
    <button id="startQuiz">Start Quiz</button>
  </div>

  <div id="material"></div>

  <div id="chat" style="display:none;">
    <div id="chatLog" style="height:200px; overflow:auto; border:1px solid #ccc;"></div>
    <input id="msgIn" placeholder="Message‚Ä¶"/><button id="sendBtn">Send</button>
  </div>

  <h2>Connection Stats</h2>
  <div id="stats">No stats yet</div>

  <script>
    // ask for a JWT (admin or user)
    const token  = prompt("Enter token (admin or user JWT)");
    const roomId = "room1";
    const proto  = location.protocol === "https:" ? "wss" : "ws";
    const ws     = new WebSocket(`${proto}://${location.host}/ws/${roomId}?token=${encodeURIComponent(token)}`);

    let ICE_SERVERS = [], pc, localStream, hasOffered = false;

    async function loadIceServers() {
      console.log("üîç Fetching ICE servers from /ice");
      const res = await fetch("/ice");
      const servers = await res.json();
      console.log("‚úÖ ICE_SERVERS loaded:", servers);
      ICE_SERVERS = servers.map(s => ({
        urls: s.urls,
        username: s.username,
        credential: s.credential
      }));
    }

    ws.onopen    = ()  => console.log("üîó WebSocket connected");
    ws.onclose   = ()  => console.log("üîå WebSocket closed");
    ws.onmessage = async e => {
      let msg;
      try { msg = JSON.parse(e.data); }
      catch { return console.error("Invalid WS JSON", e.data); }

      switch (msg.type) {
        case "waiting":
          document.getElementById("waiting").style.display = "block";
          break;
        case "new_waiting":
          document.getElementById("controls").style.display = "block";
          const opt = document.createElement("option");
          opt.value = msg.peer_id;
          opt.text  = `User ${msg.peer_id}`;
          document.getElementById("waitingList").appendChild(opt);
          break;
        case "admitted":
          document.getElementById("waiting").style.display = "none";
          document.getElementById("chat").style.display    = "block";
          document.getElementById("controls").style.display = tokenRole() === "admin" ? "block" : "none";
          break;
        case "ready_for_offer":
          if (!hasOffered) {
            hasOffered = true;
            await loadIceServers();
            await startWebRTC();
            monitorStats();
          }
          break;
        case "answer":
          await pc.setRemoteDescription({ type:"answer", sdp: msg.sdp });
          break;
        case "ice":
          await pc.addIceCandidate(msg.candidate);
          break;
        case "chat":
          const log = document.getElementById("chatLog");
          log.innerHTML += `<div><b>${msg.from}:</b> ${msg.text}</div>`;
          log.scrollTop = log.scrollHeight;
          break;
        case "material_event":
          handleMaterial(msg.event, msg.payload);
          break;
      }
    };

    async function startWebRTC() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        return alert("Microphone access is required: " + err.message);
      }

      pc = new RTCPeerConnection({
        iceServers: ICE_SERVERS,
        iceTransportPolicy: "relay"
      });

      pc.onicecandidate = ev => {
        if (ev.candidate) {
          ws.send(JSON.stringify({ type:"ice", candidate: ev.candidate.toJSON() }));
        }
      };
      pc.ontrack = ev => {
        const audio = document.createElement("audio");
        audio.srcObject = ev.streams[0];
        audio.autoplay  = true;
        document.body.appendChild(audio);
      };
      pc.onnegotiationneeded = async () => {
        await pc.setLocalDescription(await pc.createOffer());
        ws.send(JSON.stringify({ type:"offer", sdp: pc.localDescription.sdp }));
      };

      // add your mic
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    }

    function monitorStats() {
      setInterval(async () => {
        if (!pc) return;
        const stats = await pc.getStats();
        let out = "";
        stats.forEach(r => {
          if (r.type==="inbound-rtp" && r.kind==="audio") {
            const rtt = (r.roundTripTime||r.currentRoundTripTime||0).toFixed(3);
            const jit = r.jitter.toFixed(3);
            out += `RTT:${rtt}s  jitter:${jit}s\n`;
          }
        });
        document.getElementById("stats").textContent = out || "stats not yet available";
      }, 3000);
    }

    // UI hooks
    document.getElementById("sendBtn").onclick = () => {
      const txt = document.getElementById("msgIn").value;
      ws.send(JSON.stringify({ type:"chat", from: tokenRole(), text: txt }));
      document.getElementById("msgIn").value = "";
    };
    document.getElementById("admitBtn").onclick = () => {
      const peer = +document.getElementById("waitingList").value;
      ws.send(JSON.stringify({ type:"admit", peer_id: peer }));
    };
    document.getElementById("nextSlide").onclick = () =>
      ws.send(JSON.stringify({ type:"material_event", event:"next_slide" }));
    document.getElementById("startQuiz").onclick = () =>
      ws.send(JSON.stringify({ type:"material_event", event:"start_quiz", payload:{ quizId:42 } }));

    function tokenRole() {
      try {
        return JSON.parse(atob(token.split(".")[1])).role;
      } catch {
        return "user";
      }
    }
    function handleMaterial(event, payload) {
      const mat = document.getElementById("material");
      if (event==="next_slide") mat.innerHTML += "<p>‚û°Ô∏è Next slide</p>";
      if (event==="start_quiz") mat.innerHTML += `<p>‚ùì Quiz ${payload.quizId}</p>`;
    }
  </script>
</body>
</html>
